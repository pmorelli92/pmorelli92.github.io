<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>json on Dev &amp; Chill</title>
    <link>https://devandchill.com/tags/json/</link>
    <description>Recent content in json on Dev &amp; Chill</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Pablo Morelli</copyright>
    <lastBuildDate>Fri, 30 Apr 2021 12:40:00 +0200</lastBuildDate><atom:link href="https://devandchill.com/tags/json/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introducing Maybe package, bring functional to Go</title>
      <link>https://devandchill.com/posts/2021/04/introducing-maybe-package-bring-functional-to-go/</link>
      <pubDate>Fri, 30 Apr 2021 12:40:00 +0200</pubDate>
      
      <guid>https://devandchill.com/posts/2021/04/introducing-maybe-package-bring-functional-to-go/</guid>
      <description>One of the advantages of Go is that null (nil) values are rarer than in some other languages. The following snippet will fail: func getDay() string {  return nil } In order to make that snippet work, a pointer is needed as null values are the zero value for pointers (the same applies for interfaces, channels and function types).
func getDay() *string {  return nil } Being that pointers can introduce null and hence panics, and knowing that null is considered to be &amp;ldquo;The billion dollar mistake&amp;rdquo;, why is still so common in Go to use pointers for everything?</description>
    </item>
    
    <item>
      <title>Reducing loading times by a tenfold with Postgres aggregations</title>
      <link>https://devandchill.com/posts/2021/03/reducing-loading-times-by-a-tenfold-with-postgres-aggregations/</link>
      <pubDate>Sun, 21 Mar 2021 12:31:00 +0100</pubDate>
      
      <guid>https://devandchill.com/posts/2021/03/reducing-loading-times-by-a-tenfold-with-postgres-aggregations/</guid>
      <description>Time to market is a very important part of the life of the developers. In the agile world, a team must make a balance between speed and code quality. This does not necessarily mean that the code will not be good nor tested, but sometimes it limits exploration. A limited exploration means that a developer will do things the way he/she is used to.
At least from my experience, SQL is taught in university/courses in an outdated way, where a lot of new features are never explored and people are not aware of this.</description>
    </item>
    
  </channel>
</rss>
